const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const axios = require('axios');
const helmet = require('helmet');
const session = require('express-session');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const mongoose = require('mongoose');
const portscanner = require('portscanner');
const app = express();
const port = 3002;

app.use(helmet());
app.use(bodyParser.json());
app.use(cors());
app.use(session({
    secret: 'supersecretkey',
    resave: false,
    saveUninitialized: true,
    cookie: { secure: false }
}));

mongoose.connect('mongodb+srv://awl4114awl:16mC9ONVM7xEp79A@awl4114awl3.ccp1n4d.mongodb.net/?retryWrites=true&w=majority&appName=awl4114awl3', {
    useNewUrlParser: true,
    useUnifiedTopology: true
});

const UserSchema = new mongoose.Schema({
    username: String,
    password: String
});
const ScanSchema = new mongoose.Schema({
    url: String,
    date: Date,
    vulnerabilities: Array,
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
});
const User = mongoose.model('User', UserSchema);
const Scan = mongoose.model('Scan', ScanSchema);

const authenticateToken = (req, res, next) => {
    const token = req.headers['authorization'];
    if (!token) return res.sendStatus(401);

    jwt.verify(token, 'supersecretkey', (err, user) => {
        if (err) return res.sendStatus(403);
        req.user = user;
        next();
    });
};

app.post('/register', async (req, res) => {
    const { username, password } = req.body;
    const hashedPassword = await bcrypt.hash(password, 10);
    const user = new User({ username, password: hashedPassword });
    await user.save();
    res.sendStatus(201);
});

app.post('/login', async (req, res) => {
    const { username, password } = req.body;
    const user = await User.findOne({ username });
    if (user && await bcrypt.compare(password, user.password)) {
        const token = jwt.sign({ username: user.username, id: user._id }, 'supersecretkey');
        res.json({ token });
    } else {
        res.status(401).json({ message: 'Invalid credentials. Please try again.' });
    }
});

app.post('/scan', authenticateToken, async (req, res) => {
    const url = req.body.url;
    const formattedUrl = formatUrl(url);
    const vulnerabilities = await scanUrl(formattedUrl);
    const scan = new Scan({ url: formattedUrl, date: new Date(), vulnerabilities, user: req.user.id });
    await scan.save();
    res.json({ vulnerabilities });
});

app.get('/history', authenticateToken, async (req, res) => {
    const scans = await Scan.find({ user: req.user.id });
    res.json(scans);
});

function formatUrl(url) {
    if (!/^https?:\/\//i.test(url)) {
        return 'http://' + url;
    }
    return url;
}

async function scanUrl(url) {
    const vulnerabilities = [];
    try {
        const response = await axios.get(url);
        const headers = response.headers;

        // HTTP header analysis
        if (!headers['x-content-type-options'] && !headers['X-Content-Type-Options']) {
            vulnerabilities.push({ type: 'Missing Security Header', details: 'X-Content-Type-Options header is missing' });
        }
        if (!headers['strict-transport-security'] && !headers['Strict-Transport-Security']) {
            vulnerabilities.push({ type: 'Missing Security Header', details: 'Strict-Transport-Security header is missing' });
        }
        if (!headers['content-security-policy'] && !headers['Content-Security-Policy']) {
            vulnerabilities.push({ type: 'Missing Security Header', details: 'Content-Security-Policy header is missing' });
        }
        if (!/^https:\/\//i.test(url)) {
            vulnerabilities.push({ type: 'Insecure Connection', details: 'Connection is not secure (HTTPS is missing)' });
        }

        // SSL Labs API integration
        const sslLabsUrl = `https://api.ssllabs.com/api/v3/analyze?host=${url.replace(/^https?:\/\//, '')}`;
        let sslResponse;
        do {
            sslResponse = await axios.get(sslLabsUrl);
            if (sslResponse.data.status === 'IN_PROGRESS' || sslResponse.data.status === 'DNS') {
                await new Promise(resolve => setTimeout(resolve, 10000)); // wait 10 seconds before retrying
            }
        } while (sslResponse.data.status === 'IN_PROGRESS' || sslResponse.data.status === 'DNS');
        const sslDetails = {
            host: sslResponse.data.host,
            port: sslResponse.data.port,
            protocol: sslResponse.data.protocol,
            endpoints: sslResponse.data.endpoints.map(endpoint => ({
                ipAddress: endpoint.ipAddress,
                grade: endpoint.grade,
                statusMessage: endpoint.statusMessage,
                details: endpoint.statusDetailsMessage
            }))
        };
        vulnerabilities.push({ type: 'SSL/TLS Analysis', details: JSON.stringify(sslDetails, null, 2) });

        // Port scanning using portscanner
        const ports = [21, 22, 23, 25, 80, 110, 143, 443, 3306, 3389];
        const hostname = new URL(url).hostname;
        for (const port of ports) {
            const status = await portscanner.checkPortStatus(port, hostname);
            if (status === 'open') {
                vulnerabilities.push({ type: 'Open Port', details: `Port ${port} is open` });
            }
        }

        // SQL Injection Check
        const sqlPayloads = ["'", '"', 'OR 1=1', '--'];
        for (const payload of sqlPayloads) {
            try {
                await axios.get(`${url}?id=${payload}`);
                vulnerabilities.push({ type: 'Potential SQL Injection', details: `Payload "${payload}" did not trigger an error` });
            } catch (error) {
                if (error.response && (error.response.status === 500 || /sql/i.test(error.response.data))) {
                    vulnerabilities.push({ type: 'SQL Injection', details: `Payload "${payload}" triggered an error` });
                }
            }
        }

        // Basic XSS check
        const xssPayloads = ['<script>alert(1)</script>', '"><script>alert(1)</script>'];
        for (const payload of xssPayloads) {
            try {
                const xssResponse = await axios.get(`${url}?q=${payload}`);
                if (xssResponse.data.includes(payload)) {
                    vulnerabilities.push({ type: 'XSS Vulnerability', details: `Payload "${payload}" was reflected in the response` });
                }
            } catch (error) {
                // No need to handle error for XSS payloads
            }
        }

    } catch (error) {
        vulnerabilities.push({ type: 'Error', details: `Could not scan ${url}. Error: ${error.message}` });
    }
    return vulnerabilities;
}

app.use(express.static('.'));

app.listen(port, () => {
    console.log(`Server is running on http://localhost:${port}`);
});
